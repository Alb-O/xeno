//! Blob embedding and deserialization for registry metadata.
//!
//! Each domain has an embedded precompiled blob and a corresponding loader
//! function. The blobs are generated by `build.rs` from KDL source files.

use super::types::{
	ActionsBlob, CommandsBlob, GuttersBlob, HooksBlob, MotionsBlob, OptionsBlob, StatuslineBlob,
	TextObjectsBlob,
};

/// Magic bytes identifying a Xeno precompiled asset blob.
const MAGIC: &[u8; 8] = b"XENOASST";

/// Schema version for blob format compatibility.
const SCHEMA_VERSION: u32 = 1;

/// Total header size in bytes (magic + version).
const HEADER_SIZE: usize = MAGIC.len() + std::mem::size_of::<u32>();

// ── Embedded blobs ────────────────────────────────────────────────────

static ACTIONS_BLOB: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/actions.bin"));
static COMMANDS_BLOB: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/commands.bin"));
static MOTIONS_BLOB: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/motions.bin"));
static TEXT_OBJECTS_BLOB: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/text_objects.bin"));
static OPTIONS_BLOB: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/options.bin"));
static GUTTERS_BLOB: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/gutters.bin"));
static STATUSLINE_BLOB: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/statusline.bin"));
static HOOKS_BLOB: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/hooks.bin"));

// ── Validation ────────────────────────────────────────────────────────

/// Validates blob header and returns payload slice.
fn validate_blob(data: &[u8]) -> Option<&[u8]> {
	if data.len() < HEADER_SIZE {
		return None;
	}
	if &data[..8] != MAGIC {
		return None;
	}
	let version = u32::from_le_bytes(data[8..12].try_into().ok()?);
	if version != SCHEMA_VERSION {
		return None;
	}
	Some(&data[HEADER_SIZE..])
}

/// Deserializes a blob with header validation.
fn load_blob<T: serde::de::DeserializeOwned>(data: &[u8], name: &str) -> T {
	let payload = validate_blob(data).unwrap_or_else(|| panic!("invalid {name} blob header"));
	postcard::from_bytes(payload)
		.unwrap_or_else(|e| panic!("failed to deserialize {name} blob: {e}"))
}

// ── Loaders ───────────────────────────────────────────────────────────

/// Loads and deserializes the embedded action metadata blob.
pub fn load_action_metadata() -> ActionsBlob {
	load_blob(ACTIONS_BLOB, "actions")
}

/// Loads and deserializes the embedded command metadata blob.
pub fn load_command_metadata() -> CommandsBlob {
	load_blob(COMMANDS_BLOB, "commands")
}

/// Loads and deserializes the embedded motion metadata blob.
pub fn load_motion_metadata() -> MotionsBlob {
	load_blob(MOTIONS_BLOB, "motions")
}

/// Loads and deserializes the embedded text object metadata blob.
pub fn load_text_object_metadata() -> TextObjectsBlob {
	load_blob(TEXT_OBJECTS_BLOB, "text_objects")
}

/// Loads and deserializes the embedded option metadata blob.
pub fn load_option_metadata() -> OptionsBlob {
	load_blob(OPTIONS_BLOB, "options")
}

/// Loads and deserializes the embedded gutter metadata blob.
pub fn load_gutter_metadata() -> GuttersBlob {
	load_blob(GUTTERS_BLOB, "gutters")
}

/// Loads and deserializes the embedded statusline metadata blob.
pub fn load_statusline_metadata() -> StatuslineBlob {
	load_blob(STATUSLINE_BLOB, "statusline")
}

/// Loads and deserializes the embedded hook metadata blob.
pub fn load_hook_metadata() -> HooksBlob {
	load_blob(HOOKS_BLOB, "hooks")
}
