use proc_macro::TokenStream;

mod api;
mod dispatch;
mod keybindings;
mod notification;

/// Generates WASM host/guest bridge code for extension APIs.
///
/// When applied to a trait, generates:
/// - Guest-side methods that call into the host via WASM imports
/// - Host-side functions that dispatch to the trait implementation
///
/// ```ignore
/// #[evildoer_api(ExtensionHostContext)]
/// pub trait ExtensionApi {
///     fn notify(&mut self, message: &str);
///     fn get_buffer_content(&self) -> String;
/// }
/// ```
#[proc_macro_attribute]
pub fn evildoer_api(attr: TokenStream, item: TokenStream) -> TokenStream {
	api::evildoer_api(attr, item)
}

/// Registers a notification type with the notification system.
///
/// ```ignore
/// register_notification!(INFO_NOTIFICATION, "info",
///     level: evildoer_manifest::notifications::Level::Info,
///     semantic: evildoer_manifest::SEMANTIC_INFO
/// );
/// ```
#[proc_macro]
pub fn register_notification(input: TokenStream) -> TokenStream {
	notification::register_notification(input)
}

/// Derives dispatch infrastructure for `ActionResult`.
///
/// Generates handler slice declarations (`RESULT_*_HANDLERS`), a `dispatch_result`
/// function, and `is_terminal_safe` method.
///
/// Attributes:
/// - `#[handler(Foo)]` - Use `RESULT_FOO_HANDLERS` instead of deriving from variant name
/// - `#[terminal_safe]` - Mark variant as safe to execute when terminal is focused
///
/// ```ignore
/// #[derive(DispatchResult)]
/// pub enum ActionResult {
///     #[terminal_safe]
///     Ok,
///     #[handler(Quit)]
///     Quit,
///     Motion(Selection),
/// }
/// ```
#[proc_macro_derive(DispatchResult, attributes(handler, terminal_safe))]
pub fn derive_dispatch_result(input: TokenStream) -> TokenStream {
	dispatch::derive_dispatch_result(input)
}

/// Parses KDL keybinding definitions at compile time.
///
/// ```kdl
/// normal "h" "left" "ctrl-h"
/// insert "left"
/// goto "h"
/// ```
///
/// Called internally by `action!` macro:
///
/// ```ignore
/// action!(
///     move_left,
///     { description: "Move cursor left", bindings: r#"normal "h" "left""# },
///     |ctx| { ... }
/// );
/// ```
#[proc_macro]
pub fn parse_keybindings(input: TokenStream) -> TokenStream {
	keybindings::parse_keybindings(input)
}

/// Generates a [`ResultHandler`] registration for buffer-ops actions.
///
/// This proc macro exists because declarative macros cannot perform
/// `CamelCase` â†’ `SCREAMING_SNAKE_CASE` conversion, which is needed to derive
/// the handler slice name from the [`ActionResult`] variant. The slice names
/// are generated by [`DispatchResult`] using [`to_screaming_snake_case`].
///
/// Called internally by the `action!` macro's `result:` form. Given:
///
/// ```ignore
/// buffer_ops_handler!(split_horizontal, SplitHorizontal, ops, ops.split_horizontal());
/// ```
///
/// Expands to a static [`ResultHandler`] registered in `RESULT_SPLIT_HORIZONTAL_HANDLERS`:
///
/// ```ignore
/// #[distributed_slice(evildoer_manifest::actions::RESULT_SPLIT_HORIZONTAL_HANDLERS)]
/// static HANDLE_SPLIT_HORIZONTAL: ResultHandler = ResultHandler {
///     name: "split_horizontal",
///     handle: |r, ctx, _| {
///         if matches!(r, ActionResult::SplitHorizontal) {
///             if let Some(ops) = ctx.buffer_ops() {
///                 ops.split_horizontal();
///             }
///         }
///         HandleOutcome::Handled
///     },
/// };
/// ```
///
/// [`ResultHandler`]: evildoer_manifest::editor_ctx::ResultHandler
/// [`ActionResult`]: evildoer_manifest::actions::ActionResult
/// [`DispatchResult`]: crate::DispatchResult
/// [`to_screaming_snake_case`]: crate::dispatch::to_screaming_snake_case
#[proc_macro]
pub fn buffer_ops_handler(input: TokenStream) -> TokenStream {
	use quote::{format_ident, quote};
	use syn::parse::{Parse, ParseStream};
	use syn::{Expr, Ident, Token, parse_macro_input};

	struct Input {
		name: Ident,
		result: Ident,
		ops: Ident,
		body: Expr,
	}

	impl Parse for Input {
		fn parse(input: ParseStream) -> syn::Result<Self> {
			let name: Ident = input.parse()?;
			input.parse::<Token![,]>()?;
			let result: Ident = input.parse()?;
			input.parse::<Token![,]>()?;
			let ops: Ident = input.parse()?;
			input.parse::<Token![,]>()?;
			let body: Expr = input.parse()?;
			Ok(Input {
				name,
				result,
				ops,
				body,
			})
		}
	}

	let Input {
		name,
		result,
		ops,
		body,
	} = parse_macro_input!(input as Input);

	let handler_name =
		format_ident!("HANDLE_{}", dispatch::to_screaming_snake_case(&name.to_string()));
	let slice_name = format_ident!(
		"RESULT_{}_HANDLERS",
		dispatch::to_screaming_snake_case(&result.to_string())
	);

	quote! {
		#[::linkme::distributed_slice(evildoer_manifest::actions::#slice_name)]
		static #handler_name: evildoer_manifest::editor_ctx::ResultHandler =
			evildoer_manifest::editor_ctx::ResultHandler {
				name: stringify!(#name),
				handle: |r, ctx, _| {
					use evildoer_manifest::editor_ctx::MessageAccess;
					if matches!(r, evildoer_manifest::actions::ActionResult::#result) {
						if let Some(#ops) = ctx.buffer_ops() {
							#body;
						} else {
							ctx.notify("warning", "Buffer operations not available");
						}
					}
					evildoer_manifest::editor_ctx::HandleOutcome::Handled
				},
			};
	}
	.into()
}
