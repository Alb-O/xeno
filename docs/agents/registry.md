# Xeno registry systemThis guide describes the current registry architecture: build-time indices, runtime mutation via ArcSwap snapshots, explicit ID override APIs, and domain registries with derived indices kept inside the snapshot.Key files (read these first):- Runtime snapshot core: crates/registry/src/core/index/runtime.rs- Domain registries with derived indices:  - crates/registry/src/textobj/registry.rs  - crates/registry/src/options/registry.rs  - crates/registry/src/hooks/registry.rs- Database init and public surfaces: crates/registry/src/db/mod.rs- Plugin execution ordering: crates/registry/src/db/plugin.rs- Plugin definition type: crates/registry/src/core/plugin.rsScope: actions, commands, motions, themes, gutters, statusline, text objects, options, hooks, notifications.## Mental model- A registry item is a `&'static T` where `T: RegistryEntry`.- Build phase produces `RegistryIndex<T>` per domain (static/builtin content).- Runtime phase wraps the built index in a registry that owns an ArcSwap snapshot (single atomic source of truth for lookups).- Lookups are read-only and lock-free: `snap.load()` and map lookups.- Writes are atomic batches: clone snapshot → mutate → compare_and_swap (CAS) retry loop.The result is that builtins and runtime extensions are always viewed as a single coherent snapshot, not layered maps.## Data model and invariantsRegistryEntry / metadata:- `T: RegistryEntry` exposes `meta() -> &RegistryMeta`, including:  - `id`, `name`, `aliases`, `priority`, `source`, required caps, etc.Invariants to preserve:- IDs are the stable identity. Treat ID uniqueness as a rule for additive registration.- Name/alias are user-facing keys. Collisions are allowed, but must be deterministic (DuplicatePolicy).- Runtime registration is load-only (definitions are leaked to `'static` via `Box::leak` or statics).## Build flow (builtins + plugins)RegistryDb is constructed once via get_db() in crates/registry/src/db/mod.rs:1) Create a RegistryDbBuilder.2) Register builtins explicitly:   - `builtins::register_all(&mut builder)` (db/builtins.rs; not inventory-driven)3) Run plugins:   - `plugin::run_plugins(&mut builder)` (db/plugin.rs)   - plugins are collected from inventory as `PluginDef` (core/plugin.rs)   - run order is deterministic: inventory list sorted by `total_order_cmp`4) Builder produces per-domain `RegistryIndex<T>` values.5) RegistryDb wraps each built index into the runtime registry types:   - `RuntimeRegistry<T>::new(label, index)` for most domains   - domain registries for text objects/options/hooksPublic access:- Use `get_db()` and the exported LazyLock handles in db/mod.rs:  - ACTIONS, COMMANDS, MOTIONS, TEXT_OBJECTS, OPTIONS, HOOKS, etc.## RuntimeRegistry<T> (snapshot core)Implementation: crates/registry/src/core/index/runtime.rsRuntimeRegistry contains:- `builtins: RegistryIndex<T>` (kept for reference/diagnostics)- `snap: ArcSwap<Snapshot<T>>` where Snapshot contains:  - `by_id: Map<&'static str, &'static T>`  - `by_key: Map<&'static str, &'static T>` (name + aliases)  - `items_all: Vec<&'static T>` (builtins + runtime appended)  - `items_effective: Vec<&'static T>` (only winners present in by_id/by_key)  - `collisions: Vec<Collision>` (build + runtime collisions)Reads:- `get(key)` checks id first, then by_key.- `get_by_id(id)` checks by_id.- `len/is_empty/all/collisions` read from the snapshot.Writes (atomic batch):- `try_register_many(defs)`:  - loop:    - `cur = snap.load_full()`    - `next = (*cur).clone()`    - mutate next    - `compare_and_swap(&cur, Arc::new(next))`    - retry on CAS failureThis provides atomicity: either the entire batch is visible, or none is.### Explicit ID override APIsDo not use a global mutable “allow override” flag. Override is opt-in per call.APIs:- `try_register_override(def)`- `try_register_many_override(defs)`Behavioral rule:- Use non-override registration only for additive items with unique IDs.- Use override registration only when you intend to shadow an existing ID.Important nuance:- The override path treats the ID contest as admission: if the new def loses the ID contest, it is not inserted at all (no name/alias side effects).- The non-override path does not have this admission gate. Avoid registering an ID-conflicting definition via non-override unless you explicitly want “name/alias may still win” behavior.## Domain registries (derived indices inside the snapshot)These domains require extra lookup keys beyond id/name/alias. The derived indices live inside the snapshot and are updated as part of the CAS write, so runtime-registered items are visible immediately and atomically.### TextObjectRegistryImplementation: crates/registry/src/textobj/registry.rsSnapshot includes:- `by_trigger: HashMap<char, &'static TextObjectDef>`Public surface:- `get(key)`, `get_by_id(id)`- `by_trigger(ch)`- `all()`, `collisions()`, `len()`, `is_empty()`- `try_register_many`, `try_register_many_override`, plus single-item helpersTrigger resolution:- Winner selection uses the registry DuplicatePolicy (first/last/by_priority/panic).- Current code resolves trigger conflicts but does not record them into collisions. If you need trigger-conflict diagnostics, add Collision emission for trigger inserts.Replacement for old global:- Previously: TEXT_OBJECT_TRIGGER_INDEX (builtin-only LazyLock)- Now: `TEXT_OBJECTS.by_trigger(ch)` (snapshot-backed, includes runtime)### OptionsRegistryImplementation: crates/registry/src/options/registry.rsSnapshot includes:- `by_kdl: HashMap<&'static str, &'static OptionDef>`Public surface:- `get(key)`, `get_by_id(id)`- `by_kdl_key(kdl_key)`- `items()/all()`, `collisions()`, `len()`, `is_empty()`- override and non-override registration APIsReplacement for old global:- Previously: OPTION_KDL_INDEX (builtin-only LazyLock)- Now: `OPTIONS.by_kdl_key(k)` (snapshot-backed, includes runtime)Like text objects, KDL-key conflict resolution currently does not emit Collision records.### HooksRegistryImplementation: crates/registry/src/hooks/registry.rsSnapshot includes:- `by_event: HashMap<HookEvent, Vec<&'static HookDef>>`Public surface:- `get(key)`, `get_by_id(id)`- `for_event(event)` (returns a Vec today; if this becomes hot, add a slice/closure API)- `all()`, `collisions()`, `len()`, `is_empty()`- override and non-override registration APIsEvent list ordering:- Insertion uses binary_search by `total_order_cmp` to keep a stable sorted Vec per event.- This means runtime hooks are merged into the same ordered list as builtins and remain ordered after every atomic snapshot update.Replacement for old global:- Previously: BUILTIN_HOOK_BY_EVENT (builtin-only LazyLock)- Now: `HOOKS.for_event(event)` (snapshot-backed, includes runtime)## Diagnostics (how to get them now)Do not read global maps or derived static indices. Everything should come from registry surfaces.Primary diagnostics API:- `registry.collisions()` returns build-time and runtime collisions already recorded in the snapshot.- `registry.all()` / `registry.items()` returns the effective set (winners).Domain diagnostics:- Text objects: `TEXT_OBJECTS.collisions()` plus `TEXT_OBJECTS.all()` and `TEXT_OBJECTS.by_trigger(...)`.- Options: `OPTIONS.collisions()` plus `OPTIONS.items()` and `OPTIONS.by_kdl_key(...)`.- Hooks: `HOOKS.collisions()` plus `HOOKS.all()` and `HOOKS.for_event(...)`.If you need deeper inspection:- Domain registries expose `with_snapshot(|snap| ...)` to read internal maps without threading state through callers.- RuntimeRegistry<T> currently exposes the snapshot only via public getters; if you need raw-map diagnostics, add `with_snapshot` to RuntimeRegistry as well (mirror domain registries).Note on derived-key conflicts:- Trigger/KDL/event conflicts are currently resolved but not recorded as Collision entries in the provided code. If you need “why did this trigger/kdl/event resolve to X”, add Collision emission for those derived insert paths.## Task-first recipes### Add a builtin item (any domain)Where:- Builtins live under db/builtins.rs (and per-domain modules it calls).- The registry build path is db/mod.rs: builtins::register_all then plugin::run_plugins then builder.build.Steps:1) Add the builtin def and ensure it is included by builtins::register_all.2) Ensure IDs are unique within the domain.3) If you add a derived-key item (text object trigger / option kdl / hook event), ensure keys are unique or intentionally rely on DuplicatePolicy.Verify:- `cargo test -p xeno-registry` (or workspace equivalent)- `rg -n "register_all\\(|run_plugins\\(|try_register_many_override" crates/registry`### Add a plugin (startup registration)Where:- Define `PluginDef` (core/plugin.rs) and submit via inventory in your plugin crate.- Plugins are executed during RegistryDb construction (db/plugin.rs).Rules:- Plugin register function returns `Result<(), RegistryError>`.- Keep plugin register pure: only register definitions into the builder.- Ordering is deterministic: sorted by `total_order_cmp`.Verify:- `rg -n "inventory::collect!\\(PluginDef\\)" crates/registry`- `rg -n "inventory::iter::<PluginDef>" crates/registry`### Register runtime items (post-init)Choose the right API:- Additive, unique IDs: `try_register(def)` / `try_register_many(defs)` or the infallible `register/register_many`.- Intentional ID shadow: `try_register_override(def)` / `try_register_many_override(defs)`.Domain-specific derived lookups after runtime registration:- text objects: `TEXT_OBJECTS.by_trigger(ch)`- options: `OPTIONS.by_kdl_key(k)`- hooks: `HOOKS.for_event(event)`Atomicity guarantee:- Batch APIs are CAS-based; callers never observe partially applied batches.## Grep/verify cheatsheet- RegistryDb construction and flow:  - `rg -n "builtins::register_all|plugin::run_plugins|builder\\.build" crates/registry/src/db`- Snapshot write path:  - `rg -n "ArcSwap|load_full\\(|compare_and_swap\\(|try_register_many_internal" crates/registry/src/core/index/runtime.rs`- Override usage:  - `rg -n "try_register(_many)?_override" crates`- Derived index usage:  - `rg -n "by_trigger\\(|by_kdl_key\\(|for_event\\(" crates`## Minimal test checklist- Build-time duplicate IDs are rejected in indices (builder/index tests).- Runtime try_register_many is atomic (CAS loop, no partial visibility).- Explicit override methods shadow by ID without relying on any global flag.- Derived lookup APIs (by_trigger/by_kdl_key/for_event) reflect runtime registrations.- Plugin ordering is deterministic (total_order_cmp sort).- Collisions are obtainable via `.collisions()` on the registry (and used for diagnostics tooling).
