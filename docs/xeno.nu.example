# Example xeno.nu — user macro/hook definitions for Xeno.
#
# Place at ~/.config/xeno/xeno.nu
# Reload with :nu-reload, run with :nu-run <fn> [args...]
#
# Module-only: only def/use/const/alias at top level (no expressions).
#
# Built-in prelude commands available without import:
#   action, command, editor, "nu run"       — invocation constructors
#   "str ends-with", "str starts-with", "str contains" — string helpers
#
# You can also `use xeno *` explicitly (already in scope by default).

# --- Hooks ---

# Runs after every action. Return null for no-op.
export def on_action_post [name result] {
  null
}

# Runs after every registry command.
export def on_command_post [name result ...args] {
  null
}

# Runs after every editor command.
export def on_editor_command_post [name result ...args] {
  null
}

# Runs after a mode transition (e.g. Normal → Insert).
export def on_mode_change [from to] {
  null
}

# Runs after a buffer is opened or switched to via navigation.
# kind: "disk" (loaded from file) | "existing" (switched to open doc)
export def on_buffer_open [path kind] {
  null
}

# --- Macros ---

# Using built-in constructors (preferred):
export def save-and-format [] {
  [(command write), (command format)]
}

export def move-down-5 [] {
  action move_down --count 5
}

export def find-x [] {
  action find_char --char x
}

# Equivalent constructor-based form of "write then reload":
export def reload-all [] {
  [(command write), (editor reload_config)]
}

# Context-aware: read cursor/buffer state from $env.XENO_CTX.
export def show-position [] {
  let ctx = $env.XENO_CTX
  let pos = $"($ctx.cursor.line):($ctx.cursor.col)"
  let file = ($ctx.buffer.path | default "<scratch>")
  # This would need a "notify" command to be useful;
  # shown here as an example of reading XENO_CTX.
  null
}
