# Example xeno.nu — user macro/hook definitions for Xeno.
#
# Place at ~/.config/xeno/xeno.nu
# Reload with :nu-reload, run with :nu-run <fn> [args...]
#
# Module-only: only def/use/const/alias at top level (no expressions).
#
# Built-in commands available without import:
#   xeno emit                           — invocation constructor
#   xeno call                           — Nu macro invocation (chaining)
#   "xeno ctx"                         — current invocation context

# --- Hooks ---

# Runs after every action. Return null for no-op.
export def on_action_post [name: string, result: string] {
  null
}

# Runs after every registry command.
export def on_command_post [name: string, result: string, ...args: string] {
  null
}

# Runs after every editor command.
export def on_editor_command_post [name: string, result: string, ...args: string] {
  null
}

# Runs after a mode transition (e.g. Normal → Insert).
export def on_mode_change [from: string, to: string] {
  null
}

# Runs after a buffer is opened or switched to via navigation.
# kind: "disk" (loaded from file) | "existing" (switched to open doc)
export def on_buffer_open [path: string, kind: string] {
  null
}

# --- Macros ---

# Return a list of invocations to execute sequentially.
export def save-and-format [] {
  [(xeno emit command write), (xeno emit command format)]
}

# Single invocation with flags.
export def move-down-5 [] {
  xeno emit action move_down --count 5
}

export def find-x [] {
  xeno emit action find_char --char x
}

# Chain commands.
export def reload-all [] {
  [(xeno emit command write), (xeno emit editor reload_config)]
}

# Context-aware macro using `xeno ctx`.
export def smart-save [] {
  let ctx = (xeno ctx)
  if $ctx.buffer.modified {
    xeno emit command write
  }
}

# Read cursor position from context.
export def show-position [] {
  let ctx = (xeno ctx)
  let pos = $"($ctx.cursor.line):($ctx.cursor.col)"
  let file = if ($ctx.buffer.path == null) { "<scratch>" } else { $ctx.buffer.path }
  null
}
